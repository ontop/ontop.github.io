(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{471:function(t,s,a){"use strict";a.r(s);var e=a(51),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"sql-lens"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-lens"}},[t._v("#")]),t._v(" SQL Lens")]),t._v(" "),a("p",[t._v("SQL lenses are a special type of lens that can generate virtual views over any number of base relations through an arbitrary SQL query. While this allows for more flexibility, as any SQL functionalities can be used by this lens, it risks to obfuscate the inner workings towards Ontop as it may not be handled by the Ontop's SQL parser, preventing it from performing any meaningful inference and optimization.")]),t._v(" "),a("p",[t._v("One major use case for SQL lenses is to perform complex operations that are currently not supported by other Ontop lenses. For this example, we will look at the table "),a("code",[t._v("art_exhibits")]),t._v(". This table has the following schema:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("column")]),t._v(" "),a("th",[t._v("type")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("exhibit_id")]),t._v(" "),a("td",[t._v("integer")])]),t._v(" "),a("tr",[a("td",[t._v("name")]),t._v(" "),a("td",[t._v("string")])]),t._v(" "),a("tr",[a("td",[t._v("artist_name")]),t._v(" "),a("td",[t._v("string")])]),t._v(" "),a("tr",[a("td",[t._v("museum_id")]),t._v(" "),a("td",[t._v("integer")])])])]),t._v(" "),a("p",[t._v("We now want to gather more information on artists. Including how many exhibits they created and in how many museums their works appear. In SQL, this can be achieved easily by running aggregate functions on a "),a("code",[t._v("GROUP BY")]),t._v(" query, but there is no corresponding lens for aggregate functions in Ontop. We, therefore, have to take advantage of the SQL lens.")]),t._v(" "),a("p",[t._v("This lens has the following structure:")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"query"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"type"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SQLLens"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Here, the "),a("code",[t._v("query")]),t._v(" field is a single SQL query that projects all attributes that are of interest to us. In our example, we want to group all artists' names and count their number of exhibits and "),a("strong",[t._v("distinct")]),t._v(" museums. A corresponding SQL lens could look like this:")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lenses"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"artists"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"query"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT artist_name, COUNT(exhibit_id) as exhibits, COUNT(DISTINCT museum_id) as museums FROM art_exhibits GROUP BY artist_name"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"type"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SQLLens"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("This will now create a virtual relation inside Ontop, that has the columns "),a("code",[t._v("artist_name")]),t._v(", "),a("code",[t._v("exhibits")]),t._v(", and "),a("code",[t._v("museums")]),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"mapping"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mapping"}},[t._v("#")]),t._v(" Mapping")]),t._v(" "),a("p",[t._v("Finally, we just need to create a mapping entry for the artist, extending our mapping template:")]),t._v(" "),a("div",{staticClass:"language-obda extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("mappingId\tMAPID-artists\ntarget\t\tdata:artist/{artist_name} a :Artist ; :name {artist_name}^^xsd:string ; :exhibitCount {exhibits}^^xsd:integer ; :museumCount {museums}^^xsd:integer.\nsource\t\tSELECT artist_name, exhibits, museums FROM lenses.artists;\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("NOTE")]),t._v(" "),a("p",[t._v("In the "),a("code",[t._v("target")]),t._v(" clause of the mapping, our datatype properties have to be marked by their individual types. This is because Ontop can no longer infer the types of the columns we are using, as they are obfuscated by the SQL lens.")])]),t._v(" "),a("p",[t._v("To test our lenses and mapping, let us run the Ontop endpoint, copying the "),a("code",[t._v("lenses.json")]),t._v(" and "),a("code",[t._v("mapping.obda")]),t._v(" files into the endpoint's directory.\nThen, we can run the following SPARQL query:")]),t._v(" "),a("div",{staticClass:"language-SPARQL extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sparql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("PREFIX")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token prefix"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")])])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token url"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("http://example.org/museum_kg/"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?name")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?exhibits")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?museums")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?artist")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token prefix"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")])]),a("span",{pre:!0,attrs:{class:"token local-name"}},[t._v("Artist")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?artist")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token prefix"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")])]),a("span",{pre:!0,attrs:{class:"token local-name"}},[t._v("name")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?name")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?artist")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token prefix"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")])]),a("span",{pre:!0,attrs:{class:"token local-name"}},[t._v("exhibitCount")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?exhibits")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?artist")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token prefix"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")])]),a("span",{pre:!0,attrs:{class:"token local-name"}},[t._v("museumCount")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("?museums")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("If everything was done correctly, you should get a list of three artists with the number of their exhibits and the number of museums they are featured in.")]),t._v(" "),a("h3",{attrs:{id:"adding-unique-constraints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adding-unique-constraints"}},[t._v("#")]),t._v(" Adding Unique Constraints")]),t._v(" "),a("p",[t._v("Ontop cannot infer unique constraints from the expressions used in SQL lenses. However, as the user, it is clear to us that the field "),a("code",[t._v("artist_name")]),t._v(" will be "),a("em",[t._v("unique")]),t._v(", as it is used by the "),a("code",[t._v("GROUP BY")]),t._v(" clause. In such cases, explicitly adding unique constraints is a useful feature. Similarly to how it was shown in the "),a("RouterLink",{attrs:{to:"/tutorial/lenses/basic-lens.html"}},[t._v("basic lens section")]),t._v(", we can achieve this by adding an additional field to the lens:")],1),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"relations"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" \n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lenses"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"artists"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"query"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT artist_name, COUNT(exhibit_id) as exhibits, COUNT(DISTINCT museum_id) as museums FROM art_exhibits GROUP BY artist_name"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"type"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SQLLens"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"uniqueConstraints"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"added"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n                    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"uc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n                        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"determinants"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"artist_name"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n                    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("While this will not change the output of the sample query, it may help Ontop optimize its queries in specific instances (see "),a("RouterLink",{attrs:{to:"/tutorial/mapping/primary-keys.html"}},[t._v("primary key")]),t._v(").")],1),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("It is advised to be cautious when using SQL lenses. Generally, they should not refer to other lenses if the SQL expression is complex, and they may not be able to infer integrity constraints. For more information, please visit the "),a("RouterLink",{attrs:{to:"/guide/advanced/lenses.html"}},[t._v("documentation page of lenses")]),t._v(".")],1)])])}),[],!1,null,null,null);s.default=n.exports}}]);