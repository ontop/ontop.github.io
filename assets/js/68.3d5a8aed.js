(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{444:function(e,n,t){"use strict";t.r(n);var i=t(51),o=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"intermediate-query-optimization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#intermediate-query-optimization"}},[e._v("#")]),e._v(" Intermediate query optimization")]),e._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[e._v("WARNING")]),e._v(" "),t("p",[e._v("TODO: UPDATE AND CHECK (2 years old, imported from AsciiDocs)")])]),e._v(" "),t("p",[e._v("This section provides a high level description of different transformations which may be applied to "),t("a",{attrs:{href:"/dev/iq"}},[e._v("Intermediate Queries")]),e._v(" ("),t("em",[e._v("IQs")]),e._v(" in what follows) for optimization purposes.")]),e._v(" "),t("h2",{attrs:{id:"notation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#notation"}},[e._v("#")]),e._v(" Notation")]),e._v(" "),t("p",[e._v("The different types of nodes of an IQ are presented "),t("a",{attrs:{href:"/dev/iq#query-nodes"}},[e._v("in the dedicated section")]),e._v(".\nThe following notation will also be use in the current document.")]),e._v(" "),t("h3",{attrs:{id:"sub-trees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sub-trees"}},[e._v("#")]),e._v(" (Sub)trees")]),e._v(" "),t("p",[e._v("If s is a tree,\nthen root(s) will designate its root.")]),e._v(" "),t("p",[e._v('If n is a node in an IQ Q,\nthen children~Q~(n) (resp. children(n) when Q is obvious from the context) will designate the immediate children of n in Q,\nand subtree~Q~(n) (resp. subtree(n)) the maximal subtree of Q rooted in n.\nIn addition,\na "subtree of Q" will be understood as a maximal subtree of Q rooted in some node of Q.\nFinally,\nchildSubtrees~Q~(n) (resp. childSubtrees(n)) will stand for {subtree~Q~(c) | c ∈ children~Q~(n)}')]),e._v(" "),t("h3",{attrs:{id:"projected-variables"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#projected-variables"}},[e._v("#")]),e._v(" Projected variables")]),e._v(" "),t("p",[e._v("If s is a subtree in an IQ,\nthen var(s) will designate the "),t("em",[e._v("variables projected out by s")]),e._v(",\ndefined inductively as follows:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("If root(s) explicitly projects out variables (construction node,\nunion node,\ndata node or empty node),\nthen var(s) is the set of such variables.")])]),e._v(" "),t("li",[t("p",[e._v("Otherwise,\nvar(s) = ⋃ ~s∈childSubtrees(n)~ var(s)")])])]),e._v(" "),t("p",[e._v("If e is an (explicit) join or filter condition,\nthen var(e) will designate the variables appearing in e.")]),e._v(" "),t("h2",{attrs:{id:"propagating-down-boolean-expressions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#propagating-down-boolean-expressions"}},[e._v("#")]),e._v(" Propagating down boolean expressions")]),e._v(" "),t("p",[e._v("This optimization is used for (some) NoSQL underlying DBMS.\nIt consists in transforming an input IQ into an equivalent one such that,\nwhenever possible,\nselections precede other algebraic operations.\nOr in other words,\nit consists in propagating (explicit) boolean expressions down the algebraic tree.")]),e._v(" "),t("p",[e._v("Three types of IQ nodes support boolean expressions,\nnamely:")]),e._v(" "),t("ul",[t("li",[e._v("filter nodes,")]),e._v(" "),t("li",[e._v("inner join nodes, and")]),e._v(" "),t("li",[e._v("left join nodes")])]),e._v(" "),t("p",[e._v("For each node n of one of these types,\nif n has an explicit boolean expression e attached to it,\nthen e is put into DNF,\nand each resulting conjunct may be propagated down independently.\nFor instance,\nn may be a filter node,\nand e the expression (x > y) ∧ (y ≠ z).\nThen (x > y) and (y ≠ z) may both be propagated down,\nindependently from each other.\nIf n is a node of one of the three types just mentioned,\nthen bool(n) will designate the set of such conjuncts.")]),e._v(" "),t("h3",{attrs:{id:"propagation-decision-and-recipient-selection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#propagation-decision-and-recipient-selection"}},[e._v("#")]),e._v(" Propagation decision and recipient selection")]),e._v(" "),t("p",[e._v("Propagation decisions are primarily taken based on a comparison between:")]),e._v(" "),t("ul",[t("li",[e._v("the variables var(e) present in the conjunct e being propagated down,\nand")]),e._v(" "),t("li",[e._v("the variables var(s) projected out by each candidate subtree s for the propagation of e.")])]),e._v(" "),t("h4",{attrs:{id:"default-case-inner-join-of-filter-provider-node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#default-case-inner-join-of-filter-provider-node"}},[e._v("#")]),e._v(" Default case (inner join of filter provider node)")]),e._v(" "),t("p",[e._v("Let e ∈ bool(n).\nThe default rule to decide whether e can be propagated down from n is the following:\nfor each s ∈ childSubtrees(n),\nif var(e) ⊆ var(s),\nthen e can be propagated down to s.")]),e._v(" "),t("p",[e._v("An expression e being propagated down a subtree s also needs (a) new recipient node(s) to support it.\nThe recipients selection procedure is the following:")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("if root(s) is neither a union node,\nconstruction node or left join node,\nthen it is the (only) recipient of e in s.")])]),e._v(" "),t("li",[t("p",[e._v("Otherwise,\neach s' ∈ childSubtrees(root(s)) recursively becomes a new candidate subtree for propagation.\nIf there no s' ∈ childSubtrees(root(s)) to which e can be propagated down,\nthen root(s) is the (only) recipient of e in s.\nNote that in a valid IQ,\nif s is a construction or union node,\nthen var(s) ⊆ var(s') must hold for each s' ∈ childSubtrees(root(s)),\ntherefore var(e) ⊆ var(s') holds by transitivity,\nsuch that root(s) cannot be the recipient for e in s.\nBut it may be the case if s is a left join node.")])])]),e._v(" "),t("p",[e._v('Finally,\nif a recipient node r for e in s (or s\') does not natively supports non-conditional boolean expressions,\ni.e. if r is neither a filter nor an inner join node,\nthen a new filter node is created as the (immediate) parent of r,\nin order to support e.\nAlternatively (as a form of syntactic sugar),\nif the node n initially providing e is the immediate parent of r,\nthen this new filter node is not needed,\nand e can remain attached to n,\nwhich in this case plays the role of "pseudo-recipient" of e in s.')]),e._v(" "),t("p",[e._v("Note that if n is the pseudo-recipient of e in s,\nthen from the above selection procedure,\nroot(s) must be a data node,\nempty node,\ntrue node,\nor a left join node with no child accepting e,\nwhich in all cases guarantees that e cannot be further propagated down s.")]),e._v(" "),t("h4",{attrs:{id:"specific-case-left-join-provider-node"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#specific-case-left-join-provider-node"}},[e._v("#")]),e._v(" Specific case (left join provider node)")]),e._v(" "),t("p",[e._v("The propagation decision and recipient selection procedures are identical for a boolean conjunct e provided by a left join node n,\nbut with an exception:\ne may only be propagated down the subtree rooted in the right child of n.\nIndeed,\nif e was propagated down the left subtree,\nan additional selection would be added to the algebraic expression represented by that left branch,\nviolating the semantics of conditions attached to a left join (see link:intermediateQuery_detailed.adoc#leftjoinNode[the dedicated section] for an explanation).")]),e._v(" "),t("h3",{attrs:{id:"duplication-decision"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#duplication-decision"}},[e._v("#")]),e._v(" Duplication decision")]),e._v(" "),t("p",[e._v("Let e ∈ bool(n) for some node n in an IQ Q.\nAnd let us assume that there is at least one s ∈ childSubtrees(n) to which e can be propagated,\nand that in each such s,\na proper recipient node for e,\ndifferent from n,\nhas been found (or in other words that n is not the pseudo-recipient of e for any such s).")]),e._v(" "),t("p",[e._v("Then the decision still needs to be taken whether e should remain attached to n,\n(i.e. be duplicated down) or not (i.e. be strictly pushed down).")]),e._v(" "),t("h4",{attrs:{id:"default-case"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#default-case"}},[e._v("#")]),e._v(" Default case")]),e._v(" "),t("p",[e._v("By default,\nan attempt is made to strictly push down e if it can be propagated down to at least one s ∈ childSubtrees(n).\nSo in the default case,\nand provided n is not a pseudo-recipient for e in any s,\ne will not remain attached to n.")]),e._v(" "),t("h4",{attrs:{id:"specific-case-left-join-rooted-candidate-subtree"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#specific-case-left-join-rooted-candidate-subtree"}},[e._v("#")]),e._v(" Specific case (left-join-rooted candidate subtree)")]),e._v(" "),t("p",[e._v("If s is a candidate subtree for the propagation of e,\nand if a recipient node r in s has been found such that the path in Q from the provider node n of e to r comprises a left join node j and the right child j' of j,\nthen e will remain attached to the provider node n,\ni.e. e will be duplicated down,\ninstead of strictly pushed down.")]),e._v(" "),t("p",[e._v("This prevents an alteration of the semantic of the IQ.\nConsider for instance the following example (where r = j' for simplicity).")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("NOTE")]),e._v(" "),t("p",[e._v("Let:")]),e._v(" "),t("ul",[t("li",[e._v("Q1 be a well-formed IQ")]),e._v(" "),t("li",[e._v("n1 be a filter node,\nn1 ∈ Q1,\nand bool(n1) = {e},\nwhere e is the expression x < 1")]),e._v(" "),t("li",[e._v("j1 be a left join node with (explicit) joining condition x ≤ y,\nand such that children(n1) = {j1}")]),e._v(" "),t("li",[e._v("l1 be the left child of j1,\nwith var(subtree(l1)) = {y}")]),e._v(" "),t("li",[e._v("r1 be a filter node and the right child of j1,\nwith var(subtree(r1)) = {x}")])]),e._v(" "),t("p",[e._v("Then r1 is a recipient for e.")]),e._v(" "),t("p",[e._v("Now consider the query Q2 identical to Q1,\nwhere n2 (resp. j2, r2, etc.) is the counterpart of n1 (resp. j1, r1, etc.),\nbut such that e has been pushed down to r2 (and therefore is not attached to n2 anymore).\nAnd let us assume a database instance defining an evaluation function ||.||,\nsuch that ||l1|| =  { {y ↦ 2} } and ||r1|| = { {x ↦ 1} }.")]),e._v(" "),t("p",[e._v("Then ||j1|| = { {x ↦ 1, y ↦ 2} },\nand ||n1|| = { {} }.")]),e._v(" "),t("p",[e._v("But ||l2|| = { {y ↦ 2} } and ||r2|| = { {} } must also hold,\ntherefore ||j2|| = { {y ↦ 2} } and ||n2|| = { {y ↦ 2} },\nsuch that ||n1|| ≠ ||n2||.")])])])}),[],!1,null,null,null);n.default=o.exports}}]);